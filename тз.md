## ТЗ: Интеграция TON Connect (безопасная верификация кошелька)

Документ описывает, что нужно реализовать на backend для безопасной привязки TON-кошелька пользователя через TON Connect с использованием ton_proof.

### Цели
- Подтвердить, что пользователь действительно владеет адресом TON-кошелька (не просто прислал строку).
- Исключить возможность подмены адреса и повторного использования challenge (payload).
- Привязать подтверждённый адрес к аккаунту пользователя.

### Термины
- ton_proof — подпись кошелька над заданным сервером payload + метаданными (включая домен и timestamp), согласно спецификации TON Connect.
- payload — одноразовый challenge, генерируется сервером, выдаётся FE и подписывается кошельком пользователя.

---

## Конфигурация (Frontend + манифест)
- В `public/tonconnect-manifest.json` должен быть указан прод-домен приложения:
    - Пример (заменить url на прод):
    ```json
    {
        "url": "https://your.domain",
        "name": "Shipsy",
        "iconUrl": "https://your.domain/icon.png"
    }
    ```
- Домен из ton_proof (`proof.domain.value`) должен совпадать с `url` из манифеста.

---

## Эндпоинты backend

### 1) GET /tonconnect/payload
Назначение: выдать одноразовый криптостойкий payload для подписи кошельком.

Требования:
- Сгенерировать случайные 24–32 байта (или больше), вернуть как base64/hex.
- Привязать payload к текущему пользователю (по сессии/токену) и хранить TTL 2–5 минут.
- Нельзя повторно использовать один и тот же payload.

Ответ 200 OK:
```json
{
    "payload": "base64-string",
    "expireAt": 1730000000
}
```

Ошибки: 401 при отсутствии авторизации.

---

### 2) POST /tonconnect/verify
Назначение: проверить ton_proof от кошелька и привязать адрес к пользователю.

Тело запроса:
```json
{
    "address": "EQD...", // user-friendly
    "proof": {
        "timestamp": "1730000000",
        "domain": { "lengthBytes": 14, "value": "your.domain" },
        "signature": "base64",        
        "payload": "base64"
    }
}
```

Правила валидации (обязательно):
1) Найти payload у себя и убедиться, что он:
     - принадлежит текущему пользователю (по его сессии/токену);
     - не просрочен (TTL 2–5 минут);
     - ранее не использован.
2) Проверить `proof.domain.value` на равенство прод-домену из манифеста.
3) Проверить `timestamp` (±3–5 минут к текущему времени).
4) Проверить подпись (Ed25519) по спецификации TON Connect:
     - сообщение формируется согласно протоколу; 
     - публичный ключ, соответствующий адресу, действительно подписал сообщение;
     - адрес из запроса согласован с ключом подписи.
5) Пометить payload как использованный.
6) Сохранить (или обновить) адрес кошелька за пользователем в БД.

Ответ 200 OK (успех):
```json
{
    "verified": true,
    "addressNormalized": "EQ...",
    "bound": true
}
```

Ошибки (4xx):
```json
{ "verified": false, "reason": "expired|mismatch-domain|bad-signature|payload-not-found|stale-timestamp|already-used" }
```
Коды: 400/401/422 (по ситуации), 401 при отсутствии авторизации.

Примечание: можно сразу выполнять привязку кошелька в рамках этого эндпоинта и не требовать отдельный `POST /wallet`. Если нужно оставить совместимость — возвращайте `verified: true`, а FE дополнительно вызовет старый `POST /wallet`.

---

## Модель данных (предложение)
- Таблица/коллекция `wallet_proofs`:
    - user_id
    - payload (unique)
    - created_at
    - expire_at
    - used_at (nullable)
- Поле `user.wallet_address` (user-friendly нормализованный формат).

---

## Безопасность
- HTTPS обязательно (и для FE, и для манифеста).
- Payload строго привязывать к пользователю и сессии.
- Одноразовость payload (mark used).
- Логировать только метаданные (не хранить полные подписи, секреты).
- Нормализовать адрес и приводить к одному виду при хранении и сравнении.

---

## Примеры запросов

Получить payload:
```bash
curl -X GET https://api.your.domain/tonconnect/payload \
    -H "Authorization: Bearer <token>"
```

Проверить proof и привязать адрес:
```bash
curl -X POST https://api.your.domain/tonconnect/verify \
    -H "Authorization: Bearer <token>" \
    -H "Content-Type: application/json" \
    -d '{
        "address": "EQD...",
        "proof": {
            "timestamp": "1730000000",
            "domain": { "lengthBytes": 14, "value": "your.domain" },
            "signature": "Base64Signature",
            "payload": "Base64Payload"
        }
    }'
```

---

## Чек-лист приёмки
- [ ] `GET /tonconnect/payload` возвращает одноразовый payload, связанный с пользователем.
- [ ] `POST /tonconnect/verify` отвергает просроченный/чужой/повторный payload.
- [ ] Проверка домена и timestamp работает (настройка окна допуска).
- [ ] Подпись валидируется: неверная подпись → ошибка.
- [ ] Адрес сохраняется в БД только после успешной верификации.
- [ ] Повторное использование payload невозможно.
- [ ] Все ответы соответствуют схемам.

---

## Заметки по реализации (Node.js, направление)
- Для Ed25519 можно использовать `libsodium` или `tweetnacl`.
- Для нормализации адреса и работы с TON — пакеты `ton-core`/`tonweb`.
- Верификацию формируйте строго по спецификации TON Connect (см. docs и `@tonconnect/protocol`).

Этого достаточно, чтобы другой разработчик реализовал backend по безопасности и совместимости с текущим FE.